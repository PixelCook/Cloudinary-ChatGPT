import mime from 'mime';

// old and new style support
function promisify(cb, fn) {
    return new Promise(function (resolve, reject) {
        cb = cb || function (err, html) {
            if (err) {
                return reject(err);
            }
            resolve(html);
        };
        fn(cb);
    });
}


const defaultOptions = { route: '/public', default: "index.html", directory: "/" };

export function serveStatic(options, app, filestore) {
    if (!options) {
        options = defaultOptions;
    }
    let baseRoute = '';
    if (options.route && options.route !== undefined && options.route !== '/') {
        baseRoute = options.route;
    }
    // match path and file
    const regex = new RegExp(`^${baseRoute}(\/[\\w\/_-]*|[\\w\/_-]+\/)?([\\w.-]+)?(\\?[\\w=&%-]+)?$`);
    // create public access for static files
    app.auth(regex, (req, res, next) => {
        let filePath = decodeURIComponent(req.apiPath);
        
        if (filePath == options.route) {
            filePath = '/' + (options.default !== undefined ? options.default : 'index.html');
        }
        const type = mime.getType(filePath)
        if (!type) {
            next(`Static server: ${filePath} is not a valid file name`)
        } else {            
            // ok to grant public access to file
            next()
        }        
    })

    app.get(regex, async (req, res) => {
        let filePath = decodeURIComponent(req.apiPath);
        try {
            // serve root '' or '/'
            if (filePath == options.route) {
                filePath = '/' + (options.default !== undefined ? options.default : 'index.html');
            }
            // remove route from file path
            if (options.route && options.route !== undefined && options.route !== '/') {
                filePath = filePath.replace(options.route, '');
            }
            // add directory filesystem path
            if (options.directory && options.directory !== undefined && options.directory !== '/') {
                filePath = options.directory + filePath;
            }
            // serve index.html for empty sub routes '/a/b/'
            if(filePath.endsWith('/')) {
                filePath += (options.default !== undefined ? options.default : 'index.html')
            }

            // get mime type
            const type = mime.getType(filePath)
            console.debug('Serve file', filePath, type)
            const filestream = await filestore.getReadStream(filePath);
            res.set('Content-Type', type || 'application/octet-stream');
            const ONE_DAY =  86400000;
            res.set('Cache-Control', `public, max-age=${ONE_DAY*15}, s-maxage=${ONE_DAY*15}`);
            res.setHeader("Expires", new Date(Date.now() + ONE_DAY*15).toUTCString());
            res.removeHeader('Pragma');
            // stream content back to client    
            filestream
                .on('data', (buf) => {
                    res.write(buf, 'buffer')
                })
                .on('end', () => {
                    res.end()
                })

        } catch (error) {
            console.error("Error message", error.message)
            console.error(error)
            res.status(404).end('No file here:' + filePath)
        }
    })

}

/* template engine support */

let tmplCache = {};


export async function render(viewFile, data, settings, cb) {
    const engineSetting = settings['view engine'];
    const engineName = Object.keys(engineSetting)[0];
    //console.log('View engine', engineName)
    if (!engineSetting) return cb("Missing view engine");

    switch (engineName) {
        case 'ejs':
            ejs(viewFile, data, settings, cb)
            break;
        case 'handlebars':
        case 'hbs':
            handlebars(viewFile, data, settings, cb)
            break;
        default:
            cb("No view engine defined for "+engineName)
            break;
    }
}

async function ejs(viewFile, data, settings, cb) {
    try {
        //console.log('EJS engine render', viewFile, settings, cb)
        let engine = settings['view engine'].ejs;
        let layout = settings['layout'];
        let views = settings['views'];
        let tmpl = null;
        if (tmplCache[viewFile]) {                        
            tmpl = tmplCache[viewFile];
        } else {
            const txtfile = await _coho_fs.readFile(`${settings.views}/${viewFile}.ejs`);
            //console.log('Txtfile', txtfile)
            tmplCache[viewFile] = engine.compile(txtfile);
            tmpl = tmplCache[viewFile];
        }                
        cb(null, tmpl(data));        
    } catch (err) {
        cb(err);
    }
}

async function handlebars(viewFile, data, settings, cb) {
    try {
        let engine = settings['view engine'].hbs || settings['view engine'].handlebars;  
        let layout = settings['layout']; 
        let views = settings['views'];     
        let tmpl = null;
        if (tmplCache[viewFile]) {            
            tmpl = tmplCache[viewFile];
        } else {
            //console.log('Hbs view init', layout, views)
            if (layout) {
                const layoutPath = `${layout}`;
                //console.log('Layout path', layoutPath)
                const layoutFile = await _coho_fs.readFile(layoutPath);
                //console.log('Layout file', layoutFile)
                engine.registerPartial('layout', layoutFile);
            }
            const txtfile = await _coho_fs.readFile(`${settings.views}/${viewFile}.hbs`);
            //console.log('Txtfile', txtfile)
            tmplCache[viewFile] = engine.compile(txtfile);
            tmpl = tmplCache[viewFile];
        }                
        cb(null, tmpl(data));        
    } catch (err) {
        console.error('Handle bars engine error:', err)
        cb(err);
    }
}